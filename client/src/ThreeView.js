import * as THREE from 'three';
import _ from 'lodash';
import * as GeoEntities from './geoEntities';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
//import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls';
import { watch } from 'vue';
//import { getGPUTier } from "detect-gpu";

//                  * * *   * * *   * * *

// Produced event display ID to identify created event objects representations.
// Note, that it differs from the IDs used in event's main API to identify
// particular event data.
export function make_evdsp_id(type, evID, item) {
    // TODO: check `type' is within permitted collections names
    if(item.hasOwnProperty('$k') && item.hasOwnProperty('$n')) {
        return `/${evID.runNo}-${evID.spill}-${evID.eventInSpill}/${type}/${item['$k']}[${item['$n']}]`;
    } else if( item.hasOwnProperty('$k') ) {
        return `/${evID.runNo}-${evID.spill}-${evID.eventInSpill}/${type}/${item['$k']}`;
    } else if( item.hasOwnProperty('$n') ) {
        return `/${evID.runNo}-${evID.spill}-${evID.eventInSpill}/${type}[${item['$n']}]`;
    } else {
        throw new Error('Item does not provide "$k" or "$n"');
    }
}

// Parses representation object ID previously generated by `make_evdsp_id()`
export function parse_evdsp_id(s) {
    const rx = /\/(\d+)-(\d+)-(\d+)\/([^\/]+)\/([^\[]+)?([^\]+]+)?/;
    const m = s.match(rx);
    if(!m) {
        throw new Error(`String "${s}" does not match the pattern of evDsp-ID.`);
    }
    return {
        eventID: { runNo: m[1], spill: m[2], eventInSpill: m[3] },
        type: m[4],
        k: m[5],
        n: m[6],
    };
}

//                  * * *   * * *   * * *

/* Event display class
 *
 * Maintains scope with objects responsible for displaying the data. */
class ThreeView {
    // Creates and returns perspective camera + orbit controls
    _create_persp_camera(cfg) {
        cfg.aspect = this._container.clientWidth / this._container.clientHeight;  // TODO
        const cam = new THREE.PerspectiveCamera( cfg.fov
                , cfg.aspect
                , cfg.cuts[0], cfg.cuts[1]
                );
        cam.position.set( cfg.position[0], cfg.position[1], cfg.position[2] );
        //cam.lookAt(cfg.lookAt[0], cfg.lookAt[1], cfg.lookAt[2]);  // has no effect with controls
        //this._scene.add(cam);  // why does it work even without this line?

        // create new control
        const controls = new OrbitControls(cam, this._container);
        controls.addEventListener( 'change', () => {
                this._update();
                this._render();
            } );
        controls.enabled = false;

        return [cam, controls];
    }

    // Creates and returns orthograpic camera + orbit controls
    _create_ortho_camera(cfg) {
        const aspect = this._container.clientWidth
                     / this._container.clientHeight
                     ;
        const halfHeight = cfg.width/(2*aspect);
        const cam = new THREE.OrthographicCamera(
                    -cfg.width/2, cfg.width/2, // left, right
                    -halfHeight, halfHeight, // top, bottom
                    cfg.cuts[0], cfg.cuts[1]  // near, far
                    );
        cam.position.set( cfg.lookAt[0], cfg.lookAt[1], cfg.lookAt[2] );
        cam.up.set(cfg.up[0], cfg.up[1], cfg.up[2]);
        // ...
        //this._scene.add(cam);

        // create new control
        const controls = new OrbitControls(cam, this._container);
        //const controls = new TrackballControls(cam, this._container);
        controls.addEventListener( 'change', () => {
                this._update();
                this._render();
            } );
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.ROTATE
        }
        cam.updateProjectionMatrix();
        //controls.screenSpacePanning = true;
        controls.enabled = false;

        return [cam, controls];
    }

    _create_lights() {
        const mainLight = new THREE.DirectionalLight(0xffffff, 5);
        mainLight.position.set(10, 10, 10);

        const hemisphereLight = new THREE.HemisphereLight(0x99aaee, 0x202020, 5);
        this._scene.add(mainLight, hemisphereLight);
    }

    _create_meshes() {
        // create axes helper; perhaps to be removed at some point
        const axesHelper = new THREE.AxesHelper( 5 );
        this._scene.add( axesHelper );
        // create grid helper; to be removed?
        const gridHelper = new THREE.GridHelper(5000, 50, 0x444222, 0x222222);
        this._scene.add( gridHelper );
        // xxx:
        //const markers = get_markers();
        //const sprite = new THREE.Sprite( markers['whiteCircle-10x10'] );
        //this._scene.add( sprite );
    }

    _create_renderer() {
        this._renderer = new THREE.WebGLRenderer({ antialias: true });  // TODO: option?
        this._renderer.setSize( this._container.clientWidth
                              , this._container.clientHeight
                              );
        this._renderer.setPixelRatio( window.devicePixelRatio );
        //this._renderer.gammaFactor = 2.2;  // deprecated?
        this._renderer.gammaOutput = true;
        this._renderer.physicallyCorrectLights = true;

        this._container.appendChild(this._renderer.domElement);
    }

    _update() {
        const c = this._camctrls[this._cfg.currentCamera];
        const dest = this._cfg.cameras[this._cfg.currentCamera];
        if(dest['type'] == 'persp') {
            const pos = c[0].position;
            // update position
            dest.position[0] = pos.x; dest.position[1] = pos.y; dest.position[2] = pos.z;
            // update lookup
            const lat = c[1].target;
            dest.lookAt[0] = lat.x; dest.lookAt[1] = lat.y; dest.lookAt[2] = lat.z;
            dest.fov = c[0].fov;
        } else if(dest['type'] == 'ortho') {
            const pos = c[0].position;
            dest.position[0] = pos.x; dest.position[1] = pos.y; dest.position[2] = pos.z;
            const lat = c[1].target;
            dest.lookAt[0] = lat.x; dest.lookAt[1] = lat.y; dest.lookAt[2] = lat.z;
            dest.width = c[0].right - c[0].left;
            dest.cuts[0] = c[0].near;  dest.cuts[1] = c[0].far;
            dest.up[0] = c[0].up.x; dest.up[1] = c[0].up.y; dest.up[2] = c[0].up.z;
        }
    }

    _render() {
        this._renderer.render(this._scene, this.get_cam());
    }

    _update_persp_camera(newCfg, camName) {
        this._camctrls[camName][0].fov    = newCfg.fov;
        this._camctrls[camName][0].near   = newCfg.cuts[0];
        this._camctrls[camName][0].far    = newCfg.cuts[1];
        this._camctrls[camName][0].position.set( newCfg.position[0]
                                               , newCfg.position[1]
                                               , newCfg.position[2]
                                               );
        this._camctrls[camName][0].aspect = newCfg.aspect;
        this._camctrls[camName][0].lookAt( newCfg.lookAt[0]
                                         , newCfg.lookAt[1]
                                         , newCfg.lookAt[2]
                                         );
        this._camctrls[camName][1].target.set( newCfg.lookAt[0]
                                             , newCfg.lookAt[1]
                                             , newCfg.lookAt[2]
                                             );
        this._camctrls[camName][1].update();
        this._camctrls[camName][0].updateProjectionMatrix();
        this._render();
    }

    _update_ortho_camera(newCfg, camName) {
        const aspect = this._container.clientWidth
                     / this._container.clientHeight;
        const halfHeight = newCfg.width/(2*aspect);
        this._camctrls[camName][0].left     = -newCfg.width/2;
        this._camctrls[camName][0].right    =  newCfg.width/2;
        this._camctrls[camName][0].top      = -halfHeight;
        this._camctrls[camName][0].bottom   =  halfHeight;
        this._camctrls[camName][0].near     = newCfg.cuts[0];
        this._camctrls[camName][0].far      = newCfg.cuts[1];

        this._camctrls[camName][0].up.set(newCfg.up[0], newCfg.up[1], newCfg.up[2]);
        this._camctrls[camName][0].lookAt(newCfg.lookAt[0], newCfg.lookAt[1], newCfg.lookAt[2]);
        this._camctrls[camName][1].target.set(newCfg.lookAt[0], newCfg.lookAt[1], newCfg.lookAt[2]);

        this._camctrls[camName][0].updateProjectionMatrix();
        this._render();
    }

    _bind_watchers() {
        // NOTE: use getter here instead of plain reactive var

        // camera (view) switch
        watch( () => this._cfg.currentCamera
             , newCam => this._switch_cam(newCam)
             );
        // Camera position watcher
        Object.entries(this._cfg.cameras).forEach(([camName, camCfg]) => {
            if(camCfg.type == "persp") {
                watch( () => this._cfg.cameras[camName]
                     , newCfg => this._update_persp_camera(newCfg, camName)
                     , {deep:true} );
            } else if(camCfg.type == "ortho") {
                watch( () => this._cfg.cameras[camName]
                     , newCfg => this._update_ortho_camera(newCfg, camName)
                     , {deep:true} );
            }
        });
        //
        // Geometry update watcher
        //  This function is triggered on either geometry data indexed by source
        //  name gets updated, or global transformation matrix gets changed.
        watch( [ () => this._vuexStore.getters['view3D/geoData']
               , () => this._vuexStore.getters['view3D/transformationMatrix']
               ]
            , () => {
                console.debug('"geometry updated" hook triggered in ThreeViewer');
                // use values from this._vuexStore.getters['view3D/geoData']
                // to re-draw the scene
                Object
                    .entries(JSON.parse(this._vuexStore.getters['view3D/geoData']))
                    .map(([sourceName, geoDataStr]) => {
                        // update source's materials
                        var thisSourceMats = this._materials[sourceName] || {};
                        // track used material names
                        var matNamesInUse = new Set();
                        var materialsToDispose = [];
                        const geoData = JSON.parse(geoDataStr);
                        const materialDefinitions = geoData.materials || [];
                        geoData.materials.forEach((matDef_) => {
                            const { _name: matName
                                  , _type: matType
                                  , ...matDef } = matDef_;
                            if(matNamesInUse.has(matName)) {
                                throw new Error(`Material name "${matName}" met`
                                    + ` at least twice for source "${sourceName}"`);
                            }
                            matNamesInUse.add(matName);
                            if(thisSourceMats.hasOwnProperty(matName)) {
                                if(_.isEqual(thisSourceMats[matName]['matDef'])) {
                                    console.debug(`Material "${sourceName}/${matName}" unchanged.`);
                                    return;  // skip material construction
                                }
                                //thisSourceMats[matName].threeJSMaterial.dispose(); // todo: is that needed?
                                materialsToDispose.push(thisSourceMats[matName].threeJSMaterial);
                                // delete thisSourceMats[matName];  // ?
                            }
                            // otherwise, create material
                            const threeJSMaterial = GeoEntities.make_material(matType, matDef);
                            thisSourceMats[matName] = {threeJSMaterial, matDef};
                            console.debug(`Created material "${sourceName}/${matName}" of type ${matType}`);
                        });
                        // get materials not used by this source anymore, by
                        // comparing material names registered for this source
                        // and materials met in this update
                        const registeredMatNames = new Set(Object.keys(thisSourceMats));
                        const namesToDispose = registeredMatNames.difference(matNamesInUse);
                        namesToDispose.forEach((matName) => {
                                console.debug(`Material "${sourceName}/${matName}"`
                                    + ' is not used anymore -- queued for disposal.');
                                materialsToDispose.push(thisSourceMats[matName].threeJSMaterial);
                            });
                        this._materials[sourceName] = thisSourceMats;
                        // update source's geometries
                        var thisSourceGeo = this._geometries[sourceName] || {};
                        var geomNamesInUse = new Set();
                        //var geometriesToDispose = [];  // not needed, as we dispose 'em immediately
                        geoData.geometry.forEach((geoDef_) => {
                            const { _name: geoName
                                  , _type: geoType
                                  , _material: geoMaterial
                                  , ...geoDef } = geoDef_;
                            if(geomNamesInUse.has(geoName)) {
                                throw new Error(`Geometry name "${geoName}" met`
                                    + ` at least twice for source "${sourceName}"`);
                            }
                            geomNamesInUse.add(geoName);
                            // pop position and rotation properties, if
                            // provided, as we shall not re-create object on
                            // its change
                            var position = null;
                            if( geoDef.position ) {
                                position = geoDef.position;
                                delete geoDef.position;
                            }
                            var rotation = null;
                            if( geoDef.rotation ) {
                                rotation = geoDef.rotation;
                                delete geoDef.rotation;
                            }
                            var rotationOrder = null;
                            if( geoDef.rotation ) {
                                rotationOrder = geoDef.rotationOrder;
                                delete geoDef.rotationOrder;
                            }
                            // try to get material
                            if(!thisSourceMats.hasOwnProperty(geoMaterial)) {
                                console.log(`Error in geometry "${geoName}":`
                                    + ` material "${geoMaterial}" is not defined`
                                    + ` by data source "${sourceName}"; geometry`
                                    + " not constructed!" );
                                return;
                            }
                            if(thisSourceGeo.hasOwnProperty(geoName)) {
                                if( _.isEqual(thisSourceGeo[geoName].geoDef, geoDef)
                                 && geoMaterial == thisSourceGeo[geoName].geoMaterial
                                 && geoType == thisSourceGeo[geoName].geoType
                                  ) {
                                    console.debug(`Geometry "${sourceName}/${geoName}" unchanged.`);
                                    // yet, position/rotation may change
                                    if(position !== null) {
                                        thisSourceGeo[geoName].position.set(...position);
                                    }
                                    if(rotationOrder != null) {
                                        thisSourceGeo[geoName].rotation.order = rotationOrder;
                                    }
                                    if(rotation !== null) {
                                        thisSourceGeo[geoName].rotation.set(...rotation);
                                    }
                                    return;  // skip geometry construction
                                }
                                thisSourceGeo[geoName].threeJSGeo.dispose(); // TODO: is it correct?
                                // ^^^ https://discourse.threejs.org/t/correctly-remove-mesh-from-scene-and-dispose-material-and-geometry/5448
                            }
                            console.debug(`Creating geo "${geoName}" of type ${geoType}...`);
                            const threeJSGeo = GeoEntities.make_geometry(
                                    geoType, thisSourceMats[geoMaterial].threeJSMaterial, geoDef
                                );

                            this._scene.add(threeJSGeo);

                            if(position !== null) {
                                console.debug(`Placing new geometry at ${position[0]}x${position[1]}x${position[2]}`);
                                threeJSGeo.position.set(...position);
                            }
                            if(rotationOrder != null) {
                                thisSourceGeo[geoName].rotation.order = rotationOrder;
                            }
                            if(rotation !== null) {
                                console.debug(`Rotating new geometry by ${rotation[0]},${rotation[1]},${rotation[2]}`);
                                threeJSGeo.rotation.set(...rotation);
                            }
                            thisSourceGeo[geoName] = {threeJSGeo, geoDef, geoMaterial, geoType};
                            // TODO: geomNamesInUse
                        });  // end of per-geometry iteration
                        this._geometries[sourceName] = thisSourceGeo;
                        // TODO: treat materialsToDispose
                    });  // end of per-source iteration

                // XXX
                //const xxxMat = new THREE.MeshBasicMaterial({color: 0xffffaa, wireframe: true});
                //const xxxBox = new THREE.BoxGeometry(10, 10, 10);
                //const xxxMesh = new THREE.Mesh(xxxBox, xxxMat);
                //this._scene.add(xxxMesh);

                this._render();
            });  // end of watcher

        //watch( [ () => this._vuexStore.getters['view3D/staticColoredLineSegments']
        //       , () => this._vuexStore.getters['view3D/transformationMatrix']
        //       ]
        //     , () => {
        //        if(this._coloredLineSegments) {
        //            this._coloredLineSegments.objects.forEach(obj => this._scene.remove(obj));
        //            this._coloredLineSegments.geometries.forEach(geom => geom.dispose());
        //            this._coloredLineSegments.objects = [];
        //            this._coloredLineSegments.geometries = [];
        //        }
        //        
        //        const aabb = new THREE.Box3();
        //        GeoEntities.make_coloredLineSegments( this._vuexStore.getters['view3D/staticColoredLineSegments']
        //                                            , this._vuexStore.getters['view3D/transformationMatrix']
        //                                            ).forEach( renderable => {
        //                this._coloredLineSegments.objects.push(renderable.obj);
        //                this._coloredLineSegments.geometries.push(renderable.geo);
        //                aabb.expandByObject(renderable.obj);
        //                this._scene.add(renderable.obj);
        //                // TODO: if ob.name ...
        //            } );
        //        this._vuexStore.commit( 'view3D/update_region_of_interest'
        //                              , [ [aabb.min.x, aabb.min.y, aabb.min.z]
        //                                , [aabb.max.x, aabb.max.y, aabb.max.z]
        //                                ]
        //                                );
        //        /*
        //        if(this._coloredLineSegments.obj) {
        //            this._scene.remove(this._coloredLineSegments.obj);
        //            this._coloredLineSegments.obj = null;
        //            this._coloredLineSegments.geo.dispose();
        //            this._coloredLineSegments.geo = null;
        //        }
        //        // (local) state provides updated assets for static
        //        // geometry, we have to trigger three.js update here
        //        ({ obj: this._coloredLineSegments.obj, geo: this._coloredLineSegments.geo }
        //             = GeoEntities.make_coloredLineSegments( this._vuexStore.getters['view3D/staticColoredLineSegments']
        //                                                   , this._vuexStore.getters['view3D/transformationMatrix']
        //                                                   )
        //            );
        //        const aabb = new THREE.Box3();
        //         console.log('XXX', this._coloredLineSegments);  // XXX
        //        this._coloredLineSegments.forEach(item => aabb.expandByObject(item.obj));
        //        //const aabb = this._coloredLineSegments.geo.boundingBox;
        //        this._vuexStore.commit( 'view3D/update_region_of_interest'
        //                              , [ [aabb.min.x, aabb.min.y, aabb.min.z]
        //                                , [aabb.max.x, aabb.max.y, aabb.max.z]
        //                                ]
        //                                );
        //        this._scene.add(this._coloredLineSegments.obj);
        //        */
        //        this._render();
        //     });

        //watch( [ () => this._vuexStore.getters['view3D/dynamicDrawables']
        //       , () => this._vuexStore.getters['view3D/transformationMatrix']
        //       ]
        //     , () => {
        //        const aabb = new THREE.Box3();
        //        GeoEntities.gDrawableEntities.forEach( entitiesKin => {
        //            // Remove existing dynamic entities if need
        //            if( this._dynamicDrawables[entitiesKin].objects ) {
        //                // dispose entities of that kin
        //                let kin = this._dynamicDrawables[entitiesKin];
        //                if( Array.isArray(kin.objects) ) {
        //                    // remove every entity in the array
        //                    for( let i = 0; i < kin.objects.length; ++i ) {
        //                        this._scene.remove(kin.objects[i]);
        //                        kin.geometries[i].dispose();
        //                    }
        //                    kin.objects = [];
        //                    kin.geometries = [];
        //                } else {
        //                    // remove singular entity
        //                    this._scene.remove(kin.objects);
        //                    kin.objects = [];
        //                    kin.geo.dispose();
        //                    kin.geometries = [];
        //                }
        //            }
        //            // Create new ones, based on their intermediate
        //            // representantion
        //            GeoEntities[`make_${entitiesKin}`]( this._vuexStore.getters['view3D/dynamicDrawables'][entitiesKin]
        //                                              , this._vuexStore.getters['view3D/transformationMatrix']
        //                                             ).forEach( renderable => {
        //                this._dynamicDrawables[entitiesKin].objects.push(renderable.obj);
        //                this._dynamicDrawables[entitiesKin].geometries.push(renderable.geo);
        //                aabb.expandByObject(renderable.obj);
        //                this._scene.add(renderable.obj);
        //                // TODO: if ob.name ...
        //            } );
        //            /*
        //            // Add entities to scene
        //            if( this._dynamicDrawables[entitiesKin].obj ) {
        //                if( Array.isArray(this._dynamicDrawables[entitiesKin].obj) ) {
        //                    // add array of entities
        //                    let kin = this._dynamicDrawables[entitiesKin];
        //                    for( let i = 0; i < kin.obj.length; ++i ) {
        //                        this._scene.add(this._dynamicDrawables[entitiesKin].obj[i]);
        //                        this._render();
        //                    }
        //                } else {
        //                    // add singular entity
        //                    this._scene.add(this._dynamicDrawables[entitiesKin].obj);
        //                    this._render();
        //                }
        //            }*/
        //        });
        //        this._vuexStore.commit( 'view3D/update_region_of_interest'
        //                              , [ [aabb.min.x, aabb.min.y, aabb.min.z]
        //                                , [aabb.max.x, aabb.max.y, aabb.max.z]
        //                                ]
        //                                );
        //         this._render();
        //     });
    }

    // Called on camera switch; see explaination for _prevCam in ctr
    _switch_cam( newCam ) {
        if(this._prevCam)
            this._camctrls[this._prevCam][1].enabled = false;
        this._camctrls[newCam][1].enabled = true;
        this._prevCam = newCam;
        this._render();
    }

    /* Creates fixture to render things using three.js
     *
     * Optionally, creates static geometry.
     * */
    constructor(container, cfgObj, vuexStore) {
        //const gpu = getGPUTier();
        //console.log(gpu);

        // Vue's `watch()' for `reactive' object does not provide previous
        // state of watched object, but when we switch camera we have to
        // disable previous controls, so this cache is needed
        this._prevCam = null;

        this._cfg = cfgObj;
        this._vuexStore = vuexStore;
        this._container = container;

        // Placeholders for future renewable objects (we keep handles here only
        // to dispose() it at certain watchers)
        //this._coloredLineSegments = {objects: [], geometries: []};
        // Placeholders for dynamic drawables
        //this._dynamicDrawables
        //    = Object.fromEntries(GeoEntities.gDrawableEntities.map(k => [k, {objects: [], geometries: []}]));

        //
        // Index of materials by source ID {<sourceID:str>:Object}
        // Where object item is <materialName:str>:{threeJSMaterial, matDef}
        // One can compare 2nd
        this._materials = {};
        // Geometries, of similar structure to materials:
        //  {<sourceID:str>:Object}, where Object is
        //  {threeJSGeo, geoDef}
        this._geometries = {};

        // create raycaster and pointer vec
        this._pointer = new THREE.Vector2();
        this._raycaster = new THREE.Raycaster();

        // Creating the scene
        this._scene = new THREE.Scene();
        this._scene.background = new THREE.Color(0x161608);

        // Create cameras, one per entry
        this._camctrls = Object.fromEntries(Object.entries(this._cfg.cameras).map(([camName, camCfg], i) => {
                if(camCfg.type === 'persp') {
                    return [camName, this._create_persp_camera(camCfg)];
                }
                if(camCfg.type === 'ortho') {
                    return [camName, this._create_ortho_camera(camCfg)];
                }
            }));

        this._create_lights();
        this._create_meshes();
        this._create_renderer();

        this._switch_cam(this._cfg.currentCamera);

        this._render();
        
        //this._renderer.setAnimationLoop(() => {
        //    this._update();
        //    this._render();
        //});

        this._bind_watchers();
    }

    update_pointer(event) {
        this._pointer.x = ( event.clientX / this._container.clientWidth ) * 2 - 1;
	    this._pointer.y = - ( event.clientY / this._container.clientHeight ) * 2 + 1;
        // update picking ray with camera and pointer position
        this._raycaster.setFromCamera(this._pointer, this.get_cam());
        // get the intersecting objects
        const intersects = this._raycaster.intersectObjects( this._scene.children );
        const names2highlihght = intersects.filter(item => item.object.name);
        if(names2highlihght && names2highlihght.length)
            console.log('Object under cursor:', names2highlihght.map(item => item.object.name));
        //for( let i = 0; i < intersects.length; i ++ ) {
		//    //intersects[i].object.material.color.set( 0xff0000 );
        //    console.log(intersects[i]);  // XXX
        //    // ^^^ TODO: every object here has `object.name` attribute that can
        //    // be used to locate the drawable object, and `.point` vec3 that can
        //    // be used to address particular hit/line (within array).
        //    // We need to connect it with the global index of drawables...
	    //}
    }

    get_cam() {
        return this._camctrls[this._cfg.currentCamera][0];
    }

    on_resize() {
        const w = this._container.clientWidth;
        const h = this._container.clientHeight;
        this._cfg.cameras.persp1.aspect = w/h;  // ?
        //this.get_cam().aspect = w/h;
        //this._camctrls[this._cfg.currentCamera][0].aspect = w/h;  // TODO!
        //this._camctrls[this._cfg.currentCamera][0].updateProjectionMatrix();
        this._renderer.setSize(w, h);
        //this._camctrls[this._cfg.currentCamera][1].update();  // XXX
        //this._render();
    }
}  // class ThreeView

//                  * * *   * * *   * * *

// Vuex state module
const stateModule = {
    namespaced: true,
    state: () => ({
        geoDataBySource: {}, //Object.create(null),
        // serialized static geometry
        //placementsStr: '[]',
        // serialized dynamic geometry
        //dynamicGeometryStr: '[]',
        // Axis-aligned bounding box for objects of interest
        regionOfInterest: [[null, null, null], [null, null, null]],
        // Global axis scales to be applied for geometrical entities as
        // multiplication factors, f_i, r_shown = f_i * r_original.
        axesScales: [1., 1., 0.1],  // x, y, z
        // ...
    }),
    mutations: {
        // This mutation gets called from within the API's `add_data_source()'
        // action upon geometry is loaded or updated.
        update_geo_data(state, pl) {
            state.geoDataBySource[pl.name] = JSON.stringify(pl.geoData);
            console.log(`mutation:view3d/update_geo_data commited with data from "${pl.name}": "${pl.geoData}"`);  // suceeds
        },

        // Updates region of interest with given point r:float[3]
        update_region_of_interest(state, rs) {
            rs.forEach( r => {
                for(let j = 0; j < 3; ++j) {
                    if( state.regionOfInterest[0][j] === null
                     || state.regionOfInterest[0][j] > r[j] ) {
                        state.regionOfInterest[0][j] = r[j];
                    }
                    if( state.regionOfInterest[1][j] === null
                     || state.regionOfInterest[1][j] < r[j] ) {
                        state.regionOfInterest[1][j] = r[j];
                    }
                }
            });
        },
        // Re-sets region of interest to null
        reset_region_of_interest(state) {
            for(let j = 0; j < 3; ++j) {
                state.regionOfInterest[0][j] = null;
                state.regionOfInterest[1][j] = null;
            }
        },
        // Change the scales
        change_axis_scale(state, pl) {
            const nIdx = {'x':0,'y':1,'z':2}[pl['var']];
            state.axesScales[nIdx] = pl.v;
        },

        // XXX:
        // Substitutes the static geometry object
        update_placements(state, payload) {
            state.placementsStr = JSON.stringify(payload);
        },
        // Updates dynamic geometry
        update_dynamic_geometry(state, payload) {
            state.dynamicGeometryStr = JSON.stringify(payload.entities);
        },
    },
    actions: {
        // ...
    },
    getters: {
        geoData(state) {
            // NOTE: do not return simply state.geoDataBySource as it seems to
            //  turn into [Object: object] and does not launch the watcher
            //  hooks.
            return JSON.stringify(state.geoDataBySource);
        },

        //
        // Miscellaneous getters

        // Returns current global transformation (for viewing objects)
        transformationMatrix( state ) {
            const m = new THREE.Matrix3();
            m.set( state.axesScales[0], 0, 0
                 , 0, state.axesScales[1], 0
                 , 0, 0, state.axesScales[2]
                 );
            return m;
        },
        // Axis-aligned bounding box for current region of interest
        aabb(state, getters) {
            if( state.regionOfInterest.flat().some( v => v === null || Number.isNaN(v) ) ) {
                return [Array(3).fill(new THREE.Vector3(NaN, NaN, NaN))];
            }
            const mins = new THREE.Vector3( state.regionOfInterest[0][0]
                                          , state.regionOfInterest[0][1]
                                          , state.regionOfInterest[0][2]
                                       );
            const maxs = new THREE.Vector3( state.regionOfInterest[1][0]
                                          , state.regionOfInterest[1][1]
                                          , state.regionOfInterest[1][2]
                                          );
            const c = mins.clone();
            c.add(maxs).divideScalar(2.);
            return [mins, maxs, c];
        },

        //
        // TODO: remove these:

        //
        // Static geometry
        // Returns list of geometrical entities (class instances) respecting
        // loaded 
        //staticGeometry( state, getters ) {
        //    const staticGeo = JSON.parse(state.placementsStr);
        //    return Object.entries(staticGeo).map( item => {
        //            const [name, datum] = item;
        //            const {type, ...params} = datum;
        //            if(type == 'regular-wired') {
        //                const ctr = GeoEntities.get_class('FiniteCoordinateSensitivePlane');
        //                return new ctr({ ...params.measurementVectors
        //                           , size: [params.size[0], params.size[1]]
        //                           , label: name
        //                           }, getters);
        //            }
        //        } );
        //},
        //// Static geometry entities by name
        //staticEntitiesByName( state, getters ) {
        //    return Object.fromEntries( getters['staticGeometry'].map(item => {
        //            if(!item.label) return null;
        //            return [item.label, item];
        //        }).filter(e => e));
        //},
        //// Returns line segments of array of paired verteces for static geometry
        //staticColoredLineSegments( state, getters ) {
        //    return getters['staticGeometry'].map(
        //        item => item.get_colored_verteces(getters['transformationMatrix']));
        //},

        ////
        //// Dynamic geometry

        //// Dynamic geometry entities (interim, not drawable)
        //dynamicGeometry( state, getters, rootState, rootGetters ) {
        //    // Track scores ---------------------------------------------------
        //    const scoresByEvent = rootGetters['connection/trackScores'];
        //    // Below seem to me a bit like a spaghetti code: scores by event
        //    // is iterated with `GeoEntities.TrackScore()` constructor, but
        //    // in parallel `jsObjects` is also filled with tracks. A bit ugly,
        //    // but short.
        //    var jsObjects = [];  // note the order -- appended from within iterations
        //    const scoresObjs = scoresByEvent.map( ([eventID, scores]) => {
        //            const scoresMap = scores;
        //            var mcTracks = {};
        //            // Iterate over scores creating JS Objects and filling up
        //            // MC tracks for scores where MC tracks are given
        //            const scoreObjs = scoresMap.map( score => {
        //                    if( score?.mcTruth
        //                     && score.mcTruth?.geant4TrackID !== undefined
        //                     && score.mcTruth.geant4TrackID !== null
        //                      ) {
        //                        if((!(score.mcTruth.geant4TrackID in Object.keys(mcTracks)))
        //                           || mcTracks[score.mcTruth.geant4TrackID] === undefined ) {
        //                            mcTracks[score.mcTruth.geant4TrackID]
        //                                = [[score.mcTruth.globalPosition, score.sortPar]];
        //                        } else {
        //                            mcTracks[score.mcTruth.geant4TrackID].push(
        //                                [score.mcTruth.globalPosition, score.sortPar]);
        //                        }
        //                    }
        //                    try {
        //                        return new GeoEntities.TrackScore(
        //                                make_evdsp_id('scores', eventID, score),  // score ID
        //                                score,  // scoreData
        //                                getters  // getters
        //                                );
        //                    } catch(error) { console.error(error); }
        //                    return null;
        //                });
        //            // Iterate over collected MC tracks and create corresponding objectes to draw
        //            //jsObjects = jsObjects.concat([Object.entries(mcTracks).map(([trackID, scoresList]) => {
        //            //        try {
        //            //            return new GeoEntities.Track(
        //            //                    make_evdsp_id('mcTracks', eventID, {'$k':trackID}),  // track ID
        //            //                    scoresList,  // track scores
        //            //                    getters  // getters
        //            //                    );
        //            //        } catch(error) { console.error(error); }
        //            //    }).filter(el => el)]);
        //            return scoreObjs;
        //        } ).flat().filter(el => el);
        //    jsObjects = jsObjects.concat(scoresObjs);
        //    // Tracks ---------------------------------------------------------
        //    const trackObjects = rootGetters['connection/tracks'].map(([eventID, tracks]) =>
        //            tracks.map(trackItem => {
        //                    try {
        //                        // build ordered track points list based on
        //                        // referenced scores provided in inherited set
        //                        // of track item
        //                        const trackPoints = trackItem['$inherited-set']['$v'].map( (scoreRef, ordNum) => {
        //                                let scoreObj = scoreRef['$v'];
        //                                if( typeof scoreObj === 'string' )  // then deref
        //                                    scoreObj = rootGetters['connection/get_event_item'](scoreObj, eventID);
        //                                if(!Number.isNaN(scoreObj.gR[0])) {
        //                                    // score does not provide global
        //                                    // coords -- try to obtain producer
        //                                    // and calc roughly
        //                                    return [scoreObj.gR, ordNum];
        //                                }
        //                                return [scoreObj, ordNum];
        //                            } );
        //                        // create track item
        //                        return new GeoEntities.Track(
        //                                make_evdsp_id('tracks', eventID, trackItem),  // track ID
        //                                trackPoints, // track scores
        //                                getters  // getters
        //                                );
        //                    } catch(error) { console.error(error); }
        //                    return null;
        //                }).filter(trackItem => trackItem)
        //        ).flat();
        //    jsObjects = jsObjects.concat(trackObjects);
        //    // ... other drawable items?
        //    return jsObjects;
        //},
        //// Returns dictionary of dynamic drawables
        //dynamicDrawables( state, getters ) {
        //    let drawableObjects = Object.fromEntries(GeoEntities.gDrawableEntities.map(k => [k, []]));
        //    getters['dynamicGeometry'].forEach( dynGeoEntity =>
        //                        dynGeoEntity.append_dynamic_drawables(getters, drawableObjects) 
        //            );
        //    return drawableObjects;
        //}
    }
}  // stateModel

export { ThreeView, stateModule };


